function obj = uiTujDamping(obj)
% an IMPORTANT difference from uiTui: no of calculations relates to no of
% blocks, not no of sample points.
disp('uiTuj starts')

tic
pmExpoBlkhat = obj.pmExpo.block.hat;
nBlkhat = obj.no.block.hat;

if obj.indicator.enrich == 1 && obj.indicator.refine == 0
    % responses of these indices are needed: all hhat indices.
    idxCompute = obj.pmExpo.hhat(:, 1);
    nBlkComp = obj.no.block.hhat;
elseif obj.indicator.enrich == 0 && obj.indicator.refine == 1
    % responses of these indices are needed: newly added indices.
    idxAdd = cell2mat(obj.pmExpo.block.add);
    idxCompute = unique(idxAdd(:, 1));
    nBlkComp = obj.no.block.add + 1;
end

if obj.countGreedy == 0
    % initial Greedy there is no new response vectors. If countGreedy = 0,
    % there is no reuse of part 1.
    nVecNew = 0;
else
    % number of nre response vectors.
    nVecNew = obj.no.phy * obj.no.rbAdd * obj.no.t_step;
    eTeImporthhat = sortrows(obj.err.pre.hhat, 2);
    eTeImporthhat = eTeImporthhat(:, 6);
    eTeImporthat = sortrows(obj.err.pre.hat, 2);
    eTeImporthat = eTeImporthat(:, 6);
end

% for hhat, responses need to be chosen based on enrich or refine.
uStorehhat = obj.resp.store.all(idxCompute, :);
uSorthhat = sortrows(uStorehhat, 2);
% for hat, responses are all hat ones,
uStorehat = obj.resp.store.all(1:obj.no.pre.hat, :);
uSorthat = sortrows(uStorehat, 2);

nVecTot = numel(uStorehhat{1, 3});
nVecOld = nVecTot - nVecNew;

%% 1. compute uiTuj for ehat.
uReorder = cell(1);
uStoreBlkhat = cell(1);
for im = 1:nBlkhat
    % re-order pre-computed displacements.
    for ic = 1:4
        % get index.
        uReorder{ic, 1} = pmExpoBlkhat{im}(ic, 1);
        % get location in string.
        uReorder{ic, 2} = num2str(pmExpoBlkhat{im}(ic, 2:3));
        % find matching index.
        locLogi = (uReorder{ic, 1} == [uStorehat{:, 1}]');
        % re-order stored responses into clockwise sequence.
        uReorder{ic, 3} = uStorehat{locLogi, 3};
    end
    % compute the 6 combinations of responses. idx is the combination of
    % indices.
    idx = nchoosek(1:4, 2);
    for id = 1:size(idx, 1)
        
        uExtOld = uReorder{idx(id, 1), 3}(1:nVecOld);
        uExtNew = uReorder{idx(id, 1), 3}(end - nVecNew + 1:end);
        uExtpOld = uReorder{idx(id, 2), 3}(1:nVecOld);
        uExtpNew = uReorder{idx(id, 2), 3}(end - nVecNew + 1:end);
        lu11 = uTuPart(nVecOld, nVecOld, uExtOld, uExtpOld, 'rectangle');
        % part 2: right upper block, full rectangle, unsymmetric (j from 1).
        ru12 = uTuPart(nVecOld, nVecNew, uExtOld, uExtpNew, 'rectangle');
        % part 3: right lower block, right upper triangle, symmetric.
        rd22 = uTuPart(nVecNew, nVecNew, uExtNew, uExtpNew, 'rectangle');
        % part 4: left lower block, rectangle all-zeros.
        ld21 = uTuPart(nVecNew, nVecOld, uExtNew, uExtpOld, 'rectangle');
        % put part 1 2 3 4 together to form a triangular matrix.
        uTrans_ = cell2mat({lu11 ru12; ld21 rd22});
        uTrans = obj.resp.rv.L' * uTrans_ * obj.resp.rv.L;
        uReorder{idx(id, 1), 2 + idx(id, 2)} = uTrans;
        uReorder{idx(id, 1), 5 + idx(id, 2)} = uTrans_;
        
    end
    
    keyboard
    uStoreBlkhat{im} = uReorder;
end

keyboard
%% 1. compute uiTuj for ehat.
% ehat before ehhat because if refine, ehat is inherited from the previous
% ehhat. If calculate ehat after ehhat, ehat is inherited from the current
% ehhat.

% if initial, compute full for all blocks.
% if refine, inherit part 1 2 3 4 of all blocks from ehhat, no computation.
% if enrich, inherit part 1 from ehat, compute part 2 3 4 for all blocks.

% initial and enrich should be combined, by defining the new vecs and old
% vecs properly. So there is no initial when enrich.
uCell_ = cell(nBlkComp, 4);

if obj.indicator.enrich == 1 && obj.indicator.refine == 0
    % when enrich (initial or not), calculate part 1 2 3 4.
    for iPre = 1:obj.no.block.hat
        uExtOld = uSorthat{iPre, 3}(1:nVecOld);
        uExtNew = uSorthat{iPre, 3}(end - nVecNew + 1:end);
        uExtpOld = uSorthat{iPre + 1, 3}(1:nVecOld);
        uExtpNew = uSorthat{iPre + 1, 3}(end - nVecNew + 1:end);
        if obj.countGreedy == 0
            % if initial, re-compute eTe part 1.
            lu11 = uTuPart(nVecOld, nVecOld, uExtOld, uExtpOld, 'rectangle');
            
        else
            % if enrich, inherit eTe part 1.
            lu11 = eTeImporthat{iPre};
            
        end
        % part 2: right upper block, full rectangle, unsymmetric (j from 1).
        ru12 = uTuPart(nVecOld, nVecNew, uExtOld, uExtpNew, 'rectangle');
        % part 3: right lower block, right upper triangle, symmetric.
        rd22 = uTuPart(nVecNew, nVecNew, uExtNew, uExtpNew, 'rectangle');
        % part 4: left lower block, rectangle all-zeros.
        ld21 = uTuPart(nVecNew, nVecOld, uExtNew, uExtpOld, 'rectangle');
        
        % put part 1 2 3 4 together to form a triangular matrix.
        uTrans_ = cell2mat({lu11 ru12; ld21 rd22});
        uTrans = obj.resp.rv.L' * uTrans_ * obj.resp.rv.L;
        
        uCell_(iPre, 1) = {uSorthat{iPre, 1}};
        uCell_(iPre, 2) = {uSorthat{iPre, 2}};
        uCell_(iPre, 3) = {uTrans};
        uCell_(iPre, 4) = {uTrans_};
    end
    
    uCell_(nBlkComp, 1:2) = uSorthat(nBlkComp, 1:2);
    uCell_(nBlkComp, 3:4) = {[]};
    uCellSort = sortrows(uCell_, 1);
    obj.err.pre.hat(:, [4 6]) = uCellSort(:, 3:4);
elseif obj.indicator.enrich == 0 && obj.indicator.refine == 1
    % if refine (initial or not), inherit from previous ehhat.
    obj.err.pre.hat = obj.err.pre.hhat(1:obj.no.pre.hat, :);
    
end

%% 2. compute uiTuj for ehhat.
% if initial, compute full for all blocks.
% if refine, inherit the non-refined blocks from ehhat and compute full for
% refined blocks.
% if enrich, inherit part 1 from ehhat and compute part 2 3 4 for all blocks.
uCell_ = cell(nBlkComp + 1, 4);

for iPre = 1:nBlkComp
    
    uExtOld = uSorthhat{iPre, 3}(1:nVecOld);
    uExtNew = uSorthhat{iPre, 3}(end - nVecNew + 1:end);
    uExtpOld = uSorthhat{iPre + 1, 3}(1:nVecOld);
    uExtpNew = uSorthhat{iPre + 1, 3}(end - nVecNew + 1:end);
    
    % part 1: left upper block, unsymmetric.
    if obj.countGreedy == 0 || obj.indicator.enrich == 0 && ...
            obj.indicator.refine == 1
        % if initial or refine, re-compute eTe part 1.
        lu11 = uTuPart(nVecOld, nVecOld, uExtOld, uExtpOld, 'rectangle');
        
    elseif obj.indicator.enrich == 1 && obj.indicator.refine == 0
        % if enrich, inherit eTe part 1.
        lu11 = eTeImporthhat{iPre};
        
    end
    % part 2: right upper block, unsymmetric.
    ru12 = uTuPart(nVecOld, nVecNew, uExtOld, uExtpNew, 'rectangle');
    % part 3: right lower block, unsymmetric.
    rd22 = uTuPart(nVecNew, nVecNew, uExtNew, uExtpNew, 'rectangle');
    % part 4: left lower block, unsymmetric.
    ld21 = uTuPart(nVecNew, nVecOld, uExtNew, uExtpOld, 'rectangle');
    
    % put part 1 2 3 4 together to form a full rectangular matrix.
    uTrans_ = cell2mat({lu11 ru12; ld21 rd22});
    uTrans = obj.resp.rv.L' * uTrans_ * obj.resp.rv.L;
    
    uCell_(iPre, 1) = {uSorthhat{iPre, 1}};
    uCell_(iPre, 2) = {uSorthhat{iPre, 2}};
    uCell_(iPre, 3) = {uTrans};
    uCell_(iPre, 4) = {uTrans_};
    
end

uCell_(nBlkComp + 1, 1:2) = uSorthhat(nBlkComp + 1, 1:2);
uCell_(nBlkComp + 1, 3:4) = {[]};
% indices of modified rows of responses.
uModIdx = [uCell_{:, 1}];
obj.err.pre.hhat(uModIdx(1:end - 1), [4 6]) = uCell_((1:end - 1), 3:4);
toc
disp('uiTuj ends')
end